<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo-blog框架的搭建</title>
    <url>/2022/01/18/hexo-blog/</url>
    <content><![CDATA[<h1 id="hexo-blog框架的搭建"><a href="#hexo-blog框架的搭建" class="headerlink" title="hexo-blog框架的搭建"></a>hexo-blog框架的搭建</h1><hr>
<span id="more"></span>
<h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><ol>
<li>安装node.js<br>node -v #查看node的版本</li>
<li>安装npm包管理器<br>npm -v #查看npm的版本</li>
<li>利用npm安装cnmp淘宝的源<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本</li>
</ol>
<hr>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ol>
<li>cnpm install -g hexo-cli    #安装hexo框架</li>
<li>hexo -v #查看hexo的版本</li>
</ol>
<hr>
<h2 id="创建blog"><a href="#创建blog" class="headerlink" title="创建blog"></a>创建blog</h2><ol>
<li>pwd 查看当前路径</li>
<li>mkdir blog    #创建blog目录<br>如果搭建blog过程中出现问题，可以把刚刚创建的blog文件夹删除，重新开始</li>
<li>cd blog<br>hexo init #初始化一个blog 我这边没有加sudo，感觉也还行<br>结束后可以在blog文件夹下查看生成的文件</li>
<li>启动blog hexo start 简写：hexo s</li>
<li>hexo n “blog名” 新建一篇文章<br>将在source/_posts/下生成</li>
<li>cd 到blog下<br>hexo clean #清理一下<br>hexo generate 简写hexo g 生成</li>
<li>hexo s -p 端口号 暂时修改启动端口<br>hexo s 默认启动端口为4000，可能被占用</li>
</ol>
<hr>
<h2 id="将blog部署到github"><a href="#将blog部署到github" class="headerlink" title="将blog部署到github"></a>将blog部署到github</h2><ol>
<li>登陆github,new repository</li>
<li>命名仓库<br>必须是自己的昵称.github.io</li>
<li>create</li>
<li>在blog目录下安装一个部署到git的插件<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</li>
<li>设置_config.yaml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/keouyang/keouyang.github.io.git #仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li>部署到远端<br>hexo d<br>现在不能用账号密码登陆，需要去github上申请令牌<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</li>
<li>更换blog主题<br>cd blog<br>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到blog下的themes<br>修改_config.yml文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia #使用的主题</span><br></pre></td></tr></table></figure>
hexo clean<br>hexo g<br>hexo s -p 端口号 #本地部署<br>hexo d #部署到git</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>解决hexo插入图片无法正常显示</title>
    <url>/2022/01/18/hexo_picture_pro/</url>
    <content><![CDATA[<h1 id="解决hexo插入图片无法正常显示"><a href="#解决hexo插入图片无法正常显示" class="headerlink" title="解决hexo插入图片无法正常显示"></a>解决hexo插入图片无法正常显示</h1><hr>
<span id="more"></span>
<h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p><strong>图片只能放在source文件夹下可以建立一个名为image的文件夹，自己尝试放在其他地方发现不可行</strong><br><em>调用图片的方法</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片的描述](/image/xxx.png)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p><strong>首先需要修改_config.yml文件中的配置post_asset_folder设为true后，执行命令hexo new 文章名，在source/_posts中会生成与文章名相同的文件夹和一个文章名.md文件，将对应的图片放入对应的source/_posts文件夹下。即可使用相对路径引用图片资源。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="hexo中发布文章后图片无法显示"><a href="#hexo中发布文章后图片无法显示" class="headerlink" title="hexo中发布文章后图片无法显示"></a>hexo中发布文章后图片无法显示</h1><p><strong>尝试过网上的教程，10个教程9个一模一样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多次google之后总算找到了解决方法</span><br><span class="line">1.需要在source文件夹下建立一个名为images（名称可以随意）的文件夹</span><br><span class="line">2.直接在md文件中调用图片即可，使用![图片描述](/images/xxx.jpg)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo,yilia</category>
      </categories>
      <tags>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title>基于yilia主题优化bolg的页面和功能</title>
    <url>/2022/01/18/hexo_optimization/</url>
    <content><![CDATA[<h1 id="基于yilia主题优化bolg的页面和功能"><a href="#基于yilia主题优化bolg的页面和功能" class="headerlink" title="基于yilia主题优化bolg的页面和功能"></a>基于yilia主题优化bolg的页面和功能</h1><hr>
<span id="more"></span>
<h2 id="注意-如果是注释的开头不能顶格写"><a href="#注意-如果是注释的开头不能顶格写" class="headerlink" title="注意#如果是注释的开头不能顶格写"></a>注意#如果是注释的开头不能顶格写</h2><h2 id="1-配置所有文章选项"><a href="#1-配置所有文章选项" class="headerlink" title="1.配置所有文章选项"></a>1.配置所有文章选项</h2><p>** 点击全部文章会出现问题，找不到文章 **</p>
<ul>
<li>终端先到blog目录下 *</li>
<li>执行 npm i hexo-generator-json-content –save *</li>
<li>在_config.yml文件下增加下列内容，注意每一行对应的间隔数,和冒号之后的空格 *<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line">    meta: false</span><br><span class="line">    pages: false</span><br><span class="line">    posts:</span><br><span class="line">      title: true</span><br><span class="line">      date: true</span><br><span class="line">      path: true</span><br><span class="line">      text: false</span><br><span class="line">      raw: false</span><br><span class="line">      content: false</span><br><span class="line">      slug: false</span><br><span class="line">      updated: false</span><br><span class="line">      comments: false</span><br><span class="line">      link: false</span><br><span class="line">      permalink: false</span><br><span class="line">      excerpt: false</span><br><span class="line">      categories: false</span><br><span class="line">      tags: true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="hexo配置sitemap和keywords"><a href="#hexo配置sitemap和keywords" class="headerlink" title="hexo配置sitemap和keywords"></a>hexo配置sitemap和keywords</h2><p><strong>主要是对搭建的blog进行简单的seo，比如给每篇文章加上keywords,以及生成sitemap.xml文件，方便搜索引擎的搜索</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//终端转到blog目录下</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p><strong>在blog的根目录下找到_config.yml文件，增加如下代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure>
<p><strong>设置hexo博客的关键字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在blog的_config.yml下修改，采用英文逗号隔开，注意kewords和关键字之间的空格</span><br><span class="line"> # Site</span><br><span class="line">title: 站点标题</span><br><span class="line">subtitle: 站点副标题</span><br><span class="line">description: 站点描述</span><br><span class="line">author: 站点作者timeiidzone:</span><br><span class="line">keywords: 前端博客,JavaScript,html5,css3,Jquery,NodeJs,Ubuntu（#博客关键字） </span><br></pre></td></tr></table></figure>
<p><strong>设置文章的关键字</strong><br><strong>需要在blog/themes/yilia/layout/_partial下找到head.ejs文件，添加如下代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% if (page.keywords)&#123; %&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= page.keywords %&gt;,&lt;%= config.keywords %&gt;&quot;&gt;</span><br><span class="line">&lt;% &#125; else if (config.keywords)&#123; %&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot;&gt;</span><br><span class="line">&lt;%&#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>** 上述代码的意思可以解释为：如果页面有关键字，使用页面关键字，否则使用配置文件的关键字 **<br>** 在文章开头加入keywords **<br>** 不要在代码框内加 - - - 会出现问题！！！**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: ###</span><br><span class="line">date: ###</span><br><span class="line">categories: ###</span><br><span class="line">tags: ###</span><br><span class="line">keywords: ###</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="hexo设置主题头像等图片"><a href="#hexo设置主题头像等图片" class="headerlink" title="hexo设置主题头像等图片"></a>hexo设置主题头像等图片</h2><p><strong>存放位置</strong></p>
<hr>
<p>存放在/themes/yilia/source/的任意位置，可以自己新建一个文件夹，如assets，然后在assets下建立img文件夹</p>
<hr>
<p><strong>文件的配置</strong></p>
<hr>
<p>配置文件为/themes/yilia/_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root: /themes/yilia/source/ ##设置根目录</span><br><span class="line"> # 微信二维码图片</span><br><span class="line">weixin:  /assets/img/wechat.png</span><br><span class="line"> # 头像图片</span><br><span class="line">avatar:  /assets/img/head.jpg</span><br><span class="line"> # 网页图标</span><br><span class="line">favicon:  /assets/img/head.jpg</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="hexo设置主页标签和个性签名"><a href="#hexo设置主页标签和个性签名" class="headerlink" title="hexo设置主页标签和个性签名"></a>hexo设置主页标签和个性签名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在全局配置文件_config.yml中进行如下的修改</span><br><span class="line">title: KOY  //站点标题</span><br><span class="line">subtitle: KOY  //站点副标题</span><br><span class="line">description: 个人技术博客  //站点描述</span><br><span class="line">keywords: 前端博客，后端博客 //博客关键字</span><br><span class="line">author: OUYANG  //作者</span><br><span class="line">language: zh-CN  </span><br><span class="line">timezone:</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">以上的修改只能改变改变屏幕左下角的名字和网页的名字，如果想要修改头像下面的昵称需要修改yilia目录下的_config.yml文件，加上以下内容</span><br><span class="line">- - - -</span><br></pre></td></tr></table></figure>
<h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p>title: KOY<br>subtitle:<br>description: 个人技术博客<br>keywords: Hexo,c++,slam<br>author: OUYANG<br>language: zh-CN<br>timezone:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- - - -</span><br><span class="line">个性签名也在此文件aboutme处修改</span><br><span class="line">- - - -</span><br><span class="line">## 设置文章只显示摘要</span><br><span class="line">- - - -</span><br><span class="line">在_posts的md文件中正文里面添加 &lt;!--more--&gt; </span><br><span class="line">将显示more上面的内容作为文章的摘要，下面内容将隐藏，点击more将显示全文</span><br><span class="line">- - - -</span><br></pre></td></tr></table></figure>
<p> #通过修改下面文字，可以改变链接的文字<br>excerpt_link: more //例如我将其改称展开说说</p>
<pre><code>- - - -
## 参考文献
- - - -
*** https://tding.top/archives/9a232bbe.html ***
*** https://www.cnblogs.com/codecheng99/p/12380700.html ***
*** https://lrqq.github.io/2020/08/02/hexo-yilia/ ***
*** https://fuhailin.github.io/Hexo-images/ ***
*** https://www.gaotianyang.top/archives/20200717e10c0cde/ ***
</code></pre>
]]></content>
      <categories>
        <category>hexo,yilia</category>
      </categories>
      <tags>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title>LVI-SAM代码注释</title>
    <url>/2022/01/18/lvi-sam-code1/</url>
    <content><![CDATA[<h1 id="LVI-SAM代码注释"><a href="#LVI-SAM代码注释" class="headerlink" title="LVI-SAM代码注释"></a>LVI-SAM代码注释</h1><hr>
<span id="more"></span>
<h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p><em><strong>从节点关系图入手<br>在配置好环境之后运行roslaunch lvi_sam run.launch<br>之后使用rqt_graph查看节点和话题之间的连通关系<br>主要节点分别是/lvi_sam_imuPreintegration(IMU预积分点)/lvi_sam_mapOptmization(因子图优化节点) ,/lvi_sam_featureExtraction(激光雷达特征点提取节点) , /lvi_sam_imageProjection(生成深度图),/lvi_sam_visual_feature(生成视觉特征点),/lvi_sam_visual_loop(回环检测), /lvi_sam_visual_odometry(视觉里程计)</strong></em></p>
<p>1.Node:lvi_sam_imuPreintegration<br><img src="/images/imuPreintegration.jpg" alt="imu/path"><br>    1. 输入<br>    原始imu数据<br>    雷达里程计的信息<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros::Subscriber subImu;//在类里面定义</span><br><span class="line"></span><br><span class="line">ros::Subscriber subOdometry;	//在IMUPreintegration()中</span><br><span class="line"></span><br><span class="line">subImu = nh.subscribe&lt;sensor_msgs::Imu&gt; (imuTopic, 2000, &amp;IMUPreintegration::imuHandler, this, ros::TransportHints().tcpNoDelay());</span><br><span class="line"></span><br><span class="line">subOdometry = nh.subscribe&lt;nav_msgs::Odometry&gt;(PROJECT_NAME + &quot;/lidar/mapping/odometry&quot;, 5, &amp;IMUPreintegration::odometryHandler, this, ros::TransportHints().tcpNoDelay());</span><br></pre></td></tr></table></figure><br>    2. 输出<br>    imu里程计信息<br>    imu的path<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ros::Publisher pubImuOdometry;</span><br><span class="line"></span><br><span class="line">ros::Publisher pubImuPath;</span><br><span class="line"></span><br><span class="line">pubImuOdometry = nh.advertise&lt;nav_msgs::Odometry&gt; (&quot;odometry/imu&quot;, 2000);</span><br><span class="line">pubImuPath = nh.advertise&lt;nav_msgs::Path&gt; (PROJECT_NAME + &quot;/lidar/imu/path&quot;, 1);</span><br></pre></td></tr></table></figure><br>    * imu/path单纯用于rviz的显示 *<br>    <img src="/images/imu_path%E5%8D%95%E7%BA%AF%E7%94%A8%E6%9D%A5%E6%98%BE%E7%A4%BA.png" alt="imu/path"><br>    * /odometry/imu 作为视觉里程计的输入，辅助视觉里程计初始化 *<br>    <img src="/images/imu-odometry%E8%BE%93%E5%85%A5%E7%BB%99visual-odo.png" alt="/odometry/imu"></p>
<ol start="2">
<li>Node: lvi_sam_imuPreintegration</li>
</ol>
]]></content>
      <categories>
        <category>slam</category>
      </categories>
      <tags>
        <tag>LVI-SAM ; slam</tag>
      </tags>
  </entry>
  <entry>
    <title>函数-函数体</title>
    <url>/2022/01/18/%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E4%BD%93/</url>
    <content><![CDATA[<h1 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h1><hr>
<span id="more"></span>
<h2 id="函数体形成域"><a href="#函数体形成域" class="headerlink" title="函数体形成域"></a>函数体形成域</h2><p><strong>- 其中包含了自动对象（内部声明的对象以及形参对象）</strong><br><strong>- 也可包含局部静态对象，static</strong></p>
<hr>
<h2 id="函数体执行完成时的返回"><a href="#函数体执行完成时的返回" class="headerlink" title="函数体执行完成时的返回"></a>函数体执行完成时的返回</h2><p><strong>- 隐式返回，void</strong><br><strong>- 显示返回：return<br>        · return; 后面接其他语句<br>        · return 表达式；（返回类型要对应）<br>        · return 初始化列表；</strong><br><strong>-要注意当返回的对象为引用或指针时，不能返回临时对象的引用和指针</strong><br><strong>- 返回值优化（RVO）——C++17对临时对象的强制优化。返回时不调用拷贝构造函数，直接在返回值给到的对象地址进行操作，如x=fun();直接在x的地址上进行操作，在运行fun函数的时不再开辟其他空间。对于C++17对于临时对象强制进行上述操作。</strong></p>
<hr>
<h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><p><strong>- 经典方法：位于函数头的前部</strong><br><strong>- c++11引入的方式：位于函数头的后部</strong><br><strong>- c++14引入的方式：返回类型的自动推导auto<br>    ·使用constexpr if构造“具有不同返回类型”的函数，在编译器选择返回类型，在运行期返回类型唯一。</strong><br><strong>-返回类型与结构化绑定（C++17）,即返回的是一个结构体，可以直接使用auto[v1,v2]=fun(); fun{return str};</strong><br><strong>[[nodiscard]]属性加在函数体的类型前面，表明返回值很重要，提醒函数的使用者需要使用函数的返回值</strong></p>
]]></content>
      <tags>
        <tag>c++ ; 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>函数参数</title>
    <url>/2022/01/17/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数详解——参数"><a href="#函数详解——参数" class="headerlink" title="函数详解——参数"></a>函数详解——参数</h1><hr>
<span id="more"></span>
<h2 id="函数可以在函数头的小括号中包含0到多个形参"><a href="#函数可以在函数头的小括号中包含0到多个形参" class="headerlink" title="函数可以在函数头的小括号中包含0到多个形参"></a>函数可以在函数头的小括号中包含0到多个形参</h2><p><strong>- 包含零个形参时，可以使用void显式标记</strong><br><strong>- 对于非模板函数来说，其每个形参都有确定的类型，但形参可以没有名称</strong><br><strong>- 形参名称的变化并不会引入函数的不同版本，在函数重载时需要注意</strong><br><strong>- 实参到形参的拷贝求值顺序不定，编译器的类型和语言的版本都会影响，c++17强制省略复制临时对象如 int{} 在传递参数时，不会调用拷贝构造函数</strong></p>
<hr>
<h2 id="函数传值、传址、传引用"><a href="#函数传值、传址、传引用" class="headerlink" title="函数传值、传址、传引用"></a>函数传值、传址、传引用</h2><p><strong>传值，传递参数的value不会对外面的参数产生影响，一边调用拷贝构造，构建一个临时对象，对内存会产生额外的消耗</strong><br><strong>传址，即传递参数的地址，传递的一般是指针，会对传递的参数造成影响</strong><br><strong>传引用，本质上也是传递参数的地址，是传递参数的别名，会对传递的参数造成影响</strong></p>
<hr>
<h2 id="函数传参过程中的类型退化"><a href="#函数传参过程中的类型退化" class="headerlink" title="函数传参过程中的类型退化"></a>函数传参过程中的类型退化</h2><p><strong>一维数组退化成指针，二维数组退化成( * pair)[] 的指针，以此类推</strong></p>
<hr>
<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p><strong>- initializer _ list 但传递的参数类型都是一样的，实际上传递的是两个指针，一个指向列表的头，一个指向列表的尾部</strong><br><strong>- 可变长度模板参数，传入参数的类型可以不同</strong><br><strong>- 使用省略号表示形参，例如c语言print</strong></p>
<hr>
<h2 id="函数可以定义缺省实参"><a href="#函数可以定义缺省实参" class="headerlink" title="函数可以定义缺省实参"></a>函数可以定义缺省实参</h2><p><strong>- 缺省实参需要从右到左设定，如果某个形参具有缺省实参，那么它右侧的形参都必须有缺省实参</strong><br><strong>- 具有缺省实参的函数调用时，传入的实参会按照从左到右的顺序匹配形参</strong><br><strong>- 在一个翻译单元中，每个形参的缺省实参只能定义一次，在编译期进行匹配，可以多个文件配合使用</strong><br><strong>- 缺省实参为对象时，实参的缺省值会随对象值的变化而变化，例如int fun (int y=x),y的值随其前面x的变化而变化</strong></p>
<hr>
<h2 id="main函数的两个版本"><a href="#main函数的两个版本" class="headerlink" title="main函数的两个版本"></a>main函数的两个版本</h2><p><strong>- 带参数：iny agrc,char * argv[],argc代表传递给main的参数个数，agrc指向传递的字符串数组的首地址，argc最后面增加了一个空字符串，argv[0]不止代表了生成的可执行文件的名称</strong></p>
<hr>
]]></content>
      <tags>
        <tag>c++ 函数</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer30-包含min函数的栈</title>
    <url>/2022/01/18/%E5%89%91%E6%8C%87Offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<p>#剑指 30 包含min函数的栈</p>
<hr>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</strong></p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>关键在与实时找到栈中的最小元素，使用两个栈，栈1正常的先进先出，存储所有的数据，栈2保存最小数据，只有当加入栈一的数据小于栈二的顶部数据时才会入栈二，当栈一弹出的数据为最小数据时，栈二才会弹出数据，此时栈二弹出的也是最小数据。</strong></p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    //使用两个栈，栈1正常的先进先出，存储所有的数据，栈2保存最小数据，只有当加入栈一的数据小于栈二的顶部数据时才会入栈二，当栈一弹出的数据为最小数据时，栈二才会弹出数据，此时栈二弹出的也是最小数据。</span><br><span class="line">    stack&lt;int&gt; stack_normal;//存储全部数据，正常先进后出</span><br><span class="line">    stack&lt;int&gt; stack_min;//只存储最小数据</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stack_normal.push(x);</span><br><span class="line">        if(stack_min.empty())&#123;//如果当前栈为空，直接压入最小栈</span><br><span class="line">            stack_min.push(x);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(stack_min.top() &gt;= x)//栈不为空则需要判断，最小栈的顶部数据是否大于等于当前压入normal栈的数据</span><br><span class="line">                stack_min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line">        //首先需要判断栈是否为空</span><br><span class="line">        if(!stack_normal.empty())&#123;</span><br><span class="line">            //判断当前弹出的数据是否为最小值，即将stack_normal的top与stack_min的top进行比较</span><br><span class="line">            if(stack_normal.top() == stack_min.top())&#123;</span><br><span class="line">                stack_min.pop();</span><br><span class="line">                stack_normal.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else stack_normal.pop();//否则只弹出stack_normal的顶部</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        //首先判断是否为空</span><br><span class="line">        if(!stack_normal.empty())&#123;</span><br><span class="line">            return stack_normal.top();</span><br><span class="line">        &#125;</span><br><span class="line">        else return -1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        //首先判断是否为空</span><br><span class="line">        if(!stack_normal.empty())&#123;</span><br><span class="line">            return stack_min.top();//最小值即为stack_min的顶部</span><br><span class="line">        &#125;</span><br><span class="line">        else return -1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * int param_4 = obj-&gt;min();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode ; min栈 ; leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer34二叉树中和为某一值的路径</title>
    <url>/2022/01/18/%E5%89%91%E6%8C%87Offer34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h1><hr>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</strong></p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>看题目需要用到二叉树的遍历方法，采用递归遍历二叉树，这里用了二叉树的中序遍历，先遍历二叉树的根节点，然后是左孩子和右孩子。需要定义一个vector&lt;vector<int>&gt;allsolution;用来存储所有的路径，还需要定义一个vector<int> onesolution; 用来存储单条路径经过的各个节点，定义了一个sum用来表示当前路径的和。</int></int></strong><br><strong>对于一个节点，在判断非空之后，需要判断该节点是否为叶节点，如果为叶节点需要判断当前的sum是否等于target，相等则将onesloution加入allsolution。因为是叶节点，不管是否相等，在遍历没有结束之前，需要寻找下一个叶节点，要先往上回溯回到当前叶节点的根节点，所以onesolution和sum需要去除当前叶节点。</strong><br><strong>回溯到了上一个根节点，需要先遍历其右孩子，同上</strong><br><strong>遍历其右孩子后，还需要继续往上回溯，找到它的根节点，因为对于叶节点回溯时我们已经将其减去，所以这里回溯要减去的是非叶节点，这样就达到了回溯一级减去一级的root-&gt;val</strong></p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; all_solution;   //全部路径的集合</span><br><span class="line">    vector&lt;int&gt; one_solution;   //单条路径</span><br><span class="line">    int sum = 0;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int target) &#123;</span><br><span class="line">        bianli_tree(root,target);</span><br><span class="line">        return all_solution;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    void bianli_tree(TreeNode* root, int target)&#123;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            sum += root -&gt;val;//累加判断</span><br><span class="line">            one_solution.push_back(root-&gt;val);//将节点加入路径</span><br><span class="line">            if(root -&gt;left == NULL &amp;&amp; root -&gt; right ==NULL) //如果左孩子和右孩子为空，即为叶节点</span><br><span class="line">            &#123;</span><br><span class="line">                if(sum == target) //如果相等则为目标路径</span><br><span class="line">                &#123;</span><br><span class="line">                    all_solution.push_back(one_solution);//将此条其加入路径的集合</span><br><span class="line">                    //one_solution.erase(one_solution.end());//删除最后一个节点并返回</span><br><span class="line">                    //one_solution.pop_back();//删除最后一个节点</span><br><span class="line">                &#125;</span><br><span class="line">                //如果不相等则说明不是目标路径，返回上一个节点，也要删除当前叶节点</span><br><span class="line">                one_solution.pop_back();//删除最后一个节点</span><br><span class="line">                sum -= root-&gt;val;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            bianli_tree(root-&gt;left,target);//遍历左孩子</span><br><span class="line">            bianli_tree(root-&gt;right,target);//遍历右孩子</span><br><span class="line">            if(root -&gt;left != NULL || root -&gt; right !=NULL)//如果当前节点不为叶节点,往上级回溯的时候需要减去当前节点</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= root-&gt;val;</span><br><span class="line">                one_solution.pop_back();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>剑指offer ; 二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>函数重载与重载解析</title>
    <url>/2022/01/19/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p><strong>- 使用不同的函数名定义多个函数，每个函数具有不同的参数列表，注意得是参数的类型不同，与参数的名称无关。</strong><br><strong>- 不能基于不同的返回类型进行重载，因为在单独调用 fun(); 时，如果根据返回类型进行重载，编译器不知道要调用哪个。</strong><br><strong>- 函数重载与name mangling ,程序在编译器会生成可执行文件cpp.o，对于函数的重载编译器会生成一段对应的编码，可以用nm main.cpp.o 查看，使用nm main.cpp.o | c++filt -t 进行de-mangling</strong></p>
<hr>
<h2 id="重载解析-编译器如何选择正确的版本完成函数调用"><a href="#重载解析-编译器如何选择正确的版本完成函数调用" class="headerlink" title="重载解析:编译器如何选择正确的版本完成函数调用?"></a>重载解析:编译器如何选择正确的版本完成函数调用?</h2><p><strong>- Calling Functions:A Tutorial c++会议</strong></p>
<h3 id="名称查找"><a href="#名称查找" class="headerlink" title="名称查找"></a>名称查找</h3><p><strong>- 限定查找(qualified lookup)与非限定查找(unqualified lookup),限定查找指定了查找的空间，使用::作为范围限定， :: 代表全局 namespace:: 代表在该命名空间内。</strong><br><strong>- 非限定查找:逐个域进行查找，先查找当前域，如果没找到再扩大范围，逐级查。查找通常只会在已声明的名称集合中进行，就是已经编译过的部分。但要注意此时函数的顺序对查找结果会产生影响。即使该作用域内存在对于调用函数的重载，但当程序运行到调用重载函数时，还未轮到对该作用域函数的声明或者定义，但是已经全局范围内的函数重载，那么会调用全局的函数重载。</strong><br><strong>- 名称查找只关注名称，对于相同名称的变量和类型无法区分</strong><br><strong>- 实参依赖查找:当重载函数调用的实参为自定义的类型，且定义在某个命名空间下，那么即使使用的是非限定查找，也会将该命名空间纳入查找范围内</strong></p>
<hr>
<h3 id="重载解析-在名称查找的基础上进一步选择合适的调用函数"><a href="#重载解析-在名称查找的基础上进一步选择合适的调用函数" class="headerlink" title="重载解析:在名称查找的基础上进一步选择合适的调用函数"></a>重载解析:在名称查找的基础上进一步选择合适的调用函数</h3><p><strong>- 过滤不能被调用的版本(non-viable candidates)</strong><br>      ·参数个数不对<br>      ·无法将实参转换成形参<br>      ·实参不满足形参的限制条件(一般在模板函数的调用)<br><strong>- 在剩余版本中查找与调用表达式最匹配的版本，匹配级别越低越好(有特殊规则)</strong><br>      ·级别1:完美匹配 或 平凡转换 (比如加一个const)<br>      ·级别2:promotion 或 promotion 加平凡转换，如short和int、long之间的转换<br>      ·级别3:标准转换 或标准转换加平凡转换 int转成double<br>      ·级别4*:自定义转化(函数的类，派生类) 或 自定义转换加平凡转换 或 自定义转换加标准转换<br>      ·级别5*:调用形参为省略号的版本(可以和任意实参匹配)<br>      ·函数包含多个形参时，所选函数的所有形参的匹配级别都要优于或等于其他函数.比如第一个的匹配级别为1，第二个参数匹配级别为3，可能就会出错</p>
<hr>
]]></content>
      <tags>
        <tag>C++ ; 函数 ; 函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title>constexpr和consteval</title>
    <url>/2022/01/20/constexpr%E5%92%8Cconsteval/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="constexpr-c-11起"><a href="#constexpr-c-11起" class="headerlink" title="constexpr (c++11起)"></a>constexpr (c++11起)</h2><p><strong>- constexpr int x = 3;编译期常量，首先x的值无法修改如const,其次x的值在编译器就可以得到，不同于其他在运行期才能得到的数据</strong><br><strong>- constexpr函数,在函数定义中在函数的返回类型之前加入constexpr关键字，那么该函数就可以在编译期被调用，也可以在运行期执行</strong><br><strong>- constexpr函数需要保证既能在编译期运行也能在运行期运行，所以函数内部不能存在只有在运行期才能得到的结果，函数内部的结果需要在编译期获得结果</strong></p>
<hr>
<h2 id="constevel-c-20"><a href="#constevel-c-20" class="headerlink" title="constevel(c++20)"></a>constevel(c++20)</h2><p><strong>- constevel函数只能在编译期运行，强制函数在编译期执行，提高程序运行的效率</strong><br><strong>- 防止误调用</strong><br><strong>- 确保函数的定义在cpp内，编译器在编译期可以看到，与内联函数类似，是翻译单元一次定义原则</strong><br><strong>- 根据需求选择inline和constexpr关键字，一个是在编译期展开，一个是在编译期计算得到结果</strong></p>
]]></content>
      <tags>
        <tag>c++ ; constexpr ; consteval</tag>
      </tags>
  </entry>
  <entry>
    <title>内联函数</title>
    <url>/2022/01/20/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="内联函数的作用-一种优化方法"><a href="#内联函数的作用-一种优化方法" class="headerlink" title="内联函数的作用:一种优化方法"></a>内联函数的作用:一种优化方法</h2><p><strong>— 将程序在编译期展开，对于简单的函数，将其展开到程序执行的地方，可以加快程序运行的效率</strong><br><strong>— 内联函数的展开不是简单的替换，编译器自有一套完整的展开流程，使得展开前后，程序运行的效果相同</strong><br><strong>— 函数在调用时会生成栈针和销毁栈针，当一个函数被调用时，生成栈针和销毁栈针的时间比执行函数内部语句消耗的时间长时，编译器优化可能会将此函数展开成内联函数，或者使用关键字inline，这个关键字会告诉编译器试着将该函数转成inline，但是否转成内联函数需要看编译器的优化情况，不是加了inline关键字就一定能转成内联函数</strong><br><strong>— 程序级别的一次定义原则和翻译单元级别的一次定义原则。当inline函数定义在头文件时，不同的cpp文件调用inline函数时，会在调用处展开，相当于定义，相当于在程序级别定义了多次。 但加上inline关键字后，链接器在链接不同cpp生成的可执行文件时只保存一个内联函数的定义，忽略其他函数，即保证了翻译单元(cpp或多个cpp)的一次定义原则。</strong><br><strong>— 如果没有加关键字inline且函数定义在头文件中被不同的cpp文件调用就会出现重复定义的问题，即程序级别的一次定义原则，inline关键字将函数从程序级别的一次定义变成翻译单元的一次定义</strong></p>
]]></content>
      <tags>
        <tag>内联函数 ; c++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针</title>
    <url>/2022/01/21/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>   返回类型(参数类型) 如 int(int)<br>   与数组类型的类似对比<br>   相同之处<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using H = int(int);//定义一个函数类型</span><br><span class="line">H fun;//用这个函数类型定义一个函数</span><br><span class="line">using K = int[3];//定义一个数组类型</span><br><span class="line">K a;//用这个类型定义一个数组a</span><br><span class="line">int(int) fun;//这样不行</span><br><span class="line">int[3] a;//这样不行 </span><br></pre></td></tr></table></figure></p>
<p>   不同之处，函数类型只能声明一个函数，不能在后面跟上定义。</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using K = int(int);</span><br><span class="line">K fun;</span><br><span class="line">//等同于</span><br><span class="line">int fun(int);//函数的声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="函数指针类型"><a href="#函数指针类型" class="headerlink" title="函数指针类型"></a>函数指针类型</h2><p>   类比数组的指针，指向数组的指针，和指针数组<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int (*a)[3]//首先a是一个指针，指向int[3]数组，这是指向数组的指针*</span><br><span class="line"></span><br><span class="line">int* a[3];//这里a是一个数组，数组里面的对象都是int* 指针 ,即指针数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   函数指针，本质上是一个指针变量，可以接受对应类型函数的地址，并对其解引用，从而调用这个函数<br>   通常配合高阶函数使用，高阶函数接受函数指针作为它的形参<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  int inc(int x)</span><br><span class="line">&#123;</span><br><span class="line">return x+1;</span><br><span class="line">&#125;</span><br><span class="line">  int dec(int x)&#123;</span><br><span class="line">return x-1;</span><br><span class="line">&#125;</span><br><span class="line">  using H = int(int);</span><br><span class="line">  K* fun = nullptr;//给函数指针赋初值*</span><br><span class="line">  fun = &amp;inc;//获取inc函数的地址</span><br><span class="line">  std::cout&lt;&lt;(*fun)(100)&lt;&lt;std::endl;//输出202*</span><br><span class="line">  int Twice(K* fun ,int x)&#123;  //高阶函数*</span><br><span class="line">int tmp = (*fun)(x);</span><br><span class="line">return tmp * 2;</span><br><span class="line">&#125;</span><br><span class="line">  std::cout&lt;&lt;Twice(&amp;dec,100)&lt;&lt;std::endl;//输出198</span><br><span class="line">  </span><br><span class="line">  //高阶函数，泛型</span><br><span class="line">  std::vector&lt;int&gt; a&#123;1,2,3,4,5&#125;;</span><br><span class="line">  std::transform(a.begin(),a.end(),a.begin(),&amp;dec);</span><br><span class="line">  //上述transform将vector中的数据经过dec函数计算并存放到a.begin()开始的空间</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>   函数与数组都不能复制，赋值或传参时会产生类型退化</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[3];//数组</span><br><span class="line">auto b = a;//b退化成一个指针，指向a的首地址</span><br><span class="line"></span><br><span class="line">auto fun = inc;//fun不再是一个函数类型，变成了函数指针类型 int (*) int</span><br><span class="line">//再次对比数组</span><br><span class="line">using K = int[3];</span><br><span class="line">K*   -&gt; int (*)[3];// 数组的指针类型 区别与int* [3]这个还是数组，数组内的元素是指针</span><br><span class="line"></span><br><span class="line">int(int) -&gt;函数类型</span><br><span class="line">int (*)int -&gt;对应的函数指针类型</span><br><span class="line"></span><br><span class="line">using K = int(int);</span><br><span class="line">K* fun;  //等价于int(* int)(int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="函数指针与重载"><a href="#函数指针与重载" class="headerlink" title="函数指针与重载"></a>函数指针与重载</h2><p>   <strong>对于有函数重载的情况，不能使用auto对函数指针赋值，因为函数指针不能判断是哪个函数，此时需要指定函数指针的类型</strong><br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using K = void(int);</span><br><span class="line">K* x = fun;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="函数指针作为函数参数或者函数的返回值"><a href="#函数指针作为函数参数或者函数的返回值" class="headerlink" title="函数指针作为函数参数或者函数的返回值"></a>函数指针作为函数参数或者函数的返回值</h2><p><strong>注意传递的还是函数的指针，因为函数不能复制</strong></p>
<hr>
<h2 id="Most-vexing-parse"><a href="#Most-vexing-parse" class="headerlink" title="Most vexing parse"></a>Most vexing parse</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TimeKeeper time_keeper(Timer());</span><br></pre></td></tr></table></figure>
<p>   对于上面的代码有两种不同的解释<br>   第一种：使用Timer类的实例初始化定义TimeKeeper类的time_keeper变量<br>   第二种：time_keeper函数的声明，返回Timekeeper类型的对象，有一个函数(指针)类型的参数,这个函数不接收参数，返回类型是Timer<br>   <strong>原因是小括号的两种含义：对变量而言小括号内部放置数值进行变量初始化，对于函数声明小括号内部可以放置一个类型</strong><br>   <strong>解决方法：C++11引入了大括号，大括号内部只能放置对象</strong><br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//以下三种c++都会选择第一种解释，定义time_keeper变量</span><br><span class="line">TimeKeeper time_keeper(Timer&#123;&#125;);//Timer&#123;&#125;临时对象</span><br><span class="line">TimeKeeper time_keeper&#123;Timer()&#125;;//大括号内是对象，可能是函数的调用，类的调用</span><br><span class="line">TimeKeeper time_keeper&#123;Timer&#123;&#125;&#125;;//更加明确，使用缺省的方式初始化Timer对象，再使用这个对象初始化这个变量</span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
      <tags>
        <tag>函数指针 c++</tag>
      </tags>
  </entry>
  <entry>
    <title>IOStream概述</title>
    <url>/2022/01/28/IOStream%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态内存管理</title>
    <url>/2022/02/06/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="动态内存基础"><a href="#动态内存基础" class="headerlink" title="动态内存基础"></a>动态内存基础</h1><p>栈内存 与 堆内存</p>
<ul>
<li>栈内存的特点：更好的局部性，对象自动销毁（出栈），从高地址开始存储，往低地址方向存储</li>
<li>堆内存的特点：运行期动态扩展，需要显示释放，从低地址开始存储，往高地址方向存储</li>
</ul>
<p><img src="/images/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpg" alt="内存分布图"></p>
<p>· 在c++中通常使用new和delete来构造和销毁对象，但new一个对象出来的返回的都是指针 例如：int* res = new int(2); //res存储数据2的所在的地址</p>
<p>· 对象的构造分为两步：分配内存并在所分配的内存上构造对象；对象的销毁先是析构对象再将分配的内存还给系统</p>
<p>· new的几种常见形式</p>
<ul>
<li>构造单一对象/对象数组 int* x = new int[5]; //缺省初始化 int[5]{12,2,3}列表初始化 c++11之后，在删除的时候需要使用delete[] x;来销毁整个数组</li>
<li>nothrow new -&gt; int*  y = new(std::nothrow)int[5]{}; 在内存分配不成功时会将y指向nullptr，没有加nothrow时分配内存失败后会跳转到异常处理，不会执行下面的程序    - placement new 原先已经有内存空间 ，在此内存空间上构造对象，将内存分配和构造对象分离。<br>  示例： char ch[sizeof(int)];//在栈上开辟了int大小的空间，栈的空间会自动销毁<pre><code>     int* y = new (ch) int(4);//这里ch退化成char*指针，new(ch)退化成void* 指针，这里在ch对应的空间上构造对象
     //上述ch空间可以是栈内存也可以是堆内存    - new auto int* y = new auto(3); -&gt;等价于 new auto int* y = new int(3);   但不能使用new auto;它是根据后面括号表达式的内容自动推导类型
</code></pre>
</li>
</ul>
<p>· new与对象对齐<br>    - 例如struct alignas(1024) Str{}; 开辟的空间都是1024的倍数</p>
<p>· delete的常见用法<br>    - 销毁单一对象/对象数组 delete []<br>    - placement delete </p>
<p>· 使用new与delete的注意事项<br>    - 根据分配的是单一对象还是数组，采用相应的方式销毁。数组对应 delete []<br>    - delete nullptr 合法 int* x = nullptr; delete x; 合法<br>    - 不能delete一个非new返回的内存，不能去delete栈内存<br>    - 同一块内存不能delete多次<br>        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* ptr = new int(3);//ptr是一个对象，是定义在栈当中的，ptr中的数据指向堆当中分配的内存，保存地址</span><br><span class="line">std::cout&lt;&lt;ptr&lt;&lt;std::endl;</span><br><span class="line">delete ptr;//delete会清空堆当中的内存，但是ptr中的数据还是指向原来的内存地址</span><br><span class="line">std::cout&lt;&lt;ptr&lt;&lt;std::endl;//和上面打印的地址相同</span><br><span class="line">ptr = nullptr;//防止delete多次</span><br><span class="line">delete ptr;//不能delete多次</span><br></pre></td></tr></table></figure></p>
<p>· 调整系统自身的new/delete行为<br>    - 不要轻易使用</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件与内存操作</title>
    <url>/2022/02/06/%E6%96%87%E4%BB%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<p>##文件与内存操作<br>· 文件操作</p>
<ul>
<li>basic_ifstream / basic_ofstream / basic_fstream</li>
<li>用于打开读取文件 / 用于输出到文件 / 输入输出都可</li>
<li>文件流有打开和关闭两种状态，处于打开状态时无法再次打开<br>（打开意味着io绑定(关联)一个文件file，且c++规定输入输出流只能绑定一个文件），只有打开时才能i/o</li>
</ul>
<p>   代码示例：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  #include&lt;fstream&gt;</span><br><span class="line">  #include&lt;string&gt;</span><br><span class="line">  </span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">std::ofstream outfile(“my_file”);//新建一个流，初始化一个流对象</span><br><span class="line">//std::ofstream outfield;//缺省初始化</span><br><span class="line">//outfile.open(“my_file”);//打开一个文件，关联一个文件</span><br><span class="line">//outfile.close();//关闭一个流</span><br><span class="line">std::cout &lt;&lt; outille.is_open() &lt;&lt; ‘\n’;//检查这个流对象是否打开（绑定一个文件）</span><br><span class="line">outfield &lt;&lt; “hello\n”;//先将文件输入到缓存，等到close的时候再写入到文件，或者回车结束</span><br><span class="line"></span><br><span class="line">std::ifstream infile(“my_file”);</span><br><span class="line">std::string x;</span><br><span class="line">infield &gt;&gt; x;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; ‘\n’;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>· 文件流的打开模式</p>
<ul>
<li>每种文件流都有缺省的打开方式<br>标记名         作用<br>in        打开以供读取  使用两者打开时位于文件的开头<br>out        打开以供写入<br>ate        表示起始位置位于文件末尾<br>app        附加文件，即总是向文件尾写入<br>trunc        截断文件，即删除文件中的内容，打开文件时清除文件中的字符<br>binary        二进制模式</li>
</ul>
<pre><code>std::ios_base::in | std::ios_base::ate;
//两种模式按位或，因为c++设计时一遍将in ate设置成整数 类似00000001

- 注意ate与app的异同 
ate在打开后可以修改写和读的位置，通过修改文件中的指针，但是app不能修改，只能放在文件的末尾

- binary能禁止系统特定的转换

- 避免意义不明确的流的使用方式（如ifstream+out）

![合法的打开方式组合](/images/合法的打开方式组合.jpg)
</code></pre>
<hr>
<p>· 内存流：basic_istringstream / basic_ostringstream / basic_stringstream<br>    · 也会受打开模式的影响：in/out/ate/app的影响</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">std::ostringstream obj1;//内存流输出对象</span><br><span class="line">obj1 &lt;&lt; 10;//将10输出到内存中</span><br><span class="line">std::string res = obj1.str();</span><br><span class="line"></span><br><span class="line">std::istringstream obj2(res);//内存流输入对象</span><br><span class="line"></span><br><span class="line">std::ostringstream buf2(“test”,std::ios_base::ate);//输出到test后面到内存空间</span><br><span class="line">buf2 &lt;&lt; ‘1’;</span><br><span class="line">std::cout &lt;&lt; buf2.str() &lt;&lt; ’\n’;//输出为test1</span><br><span class="line"></span><br><span class="line">std::ostringstream buf2(“test”);//输出到内存空间，会从test位置的t开始</span><br><span class="line">buf2 &lt;&lt; ‘1’;</span><br><span class="line">std::cout &lt;&lt; buf2.str() &lt;&lt; ’\n’;//输出为1est</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

· 使用str()方法获取底层所对应的字符串，返回的是一个右值
    - 要小心使用str().c_str()的形式获取c风格的字符串
    - auto c_res  = buf2.str().c_str();//auto获取的是一个指针，指向了字符开头的位置
        而buf2.str()是一个右值，存活周期为该语句结束，在该语句结束时内存被释放

· 基于字符串流的字符串拼接优化操作
    std::string x;
    x += “hello”;
    x += “world”;
    //性能较差，string已经有一个内存，在拼接时会开辟新的内存空间
        先将原来内存空间的数据存储到新的内存空间，再将新的数据附加到新的内存后面，再销毁原来的内存空间
        涉及到内存的拷贝，和内存的开辟销毁，会耗费较多时间


· std::ostringstream obj;//
    obj &lt;&lt; “hello”;
    obj &lt;&lt; “world”;
    std::cout&lt;&lt;obj.str()&lt;&lt;std::endl;
    //内部维护一个缓冲区，现将数据填入缓冲区（缓冲区一般较大），当缓冲区满了之后或者写入时，再进行内存的开辟与写入
</code></pre>
]]></content>
      <tags>
        <tag>C++ ，内存</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针1</title>
    <url>/2022/02/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%881/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>· 使用new和delete的问题：内存所有权不清晰，容易产生不销毁，多销毁的情况</p>
<p>· c++的解决方案:智能指针</p>
<ul>
<li>智能指针是一个抽象类，在销毁的时候会调用析构函数处理new的内存等</li>
<li>auto_ptr(c++17删除)第一个标准不成熟有很多问题,不建议使用</li>
<li>shared_ptr/uniuqe_ptr/weak_ptr 需要引入头文件<memory></memory></li>
</ul>
<h2 id="share-ptr-—-基于引用计数的共享内存解决方案"><a href="#share-ptr-—-基于引用计数的共享内存解决方案" class="headerlink" title="share_ptr — 基于引用计数的共享内存解决方案"></a>share_ptr — 基于引用计数的共享内存解决方案</h2><ul>
<li><p>基本用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; x(new int(3));//等价于std::shared_ptr&lt;int&gt; x = new int(3);</span><br><span class="line">std::cout&lt;&lt;x.use_count()&lt;&lt;std::endl;//打印引用计数</span><br><span class="line">std::shared_ptr&lt;int&gt; y = x;//此时引用计数加1，变为2 </span><br><span class="line">std::cout&lt;&lt;y.use_count()&lt;&lt;std::endl;//打印引用计数为2，因为xy共同使用一个对象</span><br><span class="line">//在引用计数为0的时候自动调用delete</span><br></pre></td></tr></table></figure></li>
<li><p>reset/get 方法</p>
</li>
</ul>
<pre><code>- get() : 将shared_ptr指针和老旧的类型指针联系，使用get()方法将shared_ptr类型转化为对应的指针类型，返回数据的地址，不包含引用计数的地址
    例如：
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; x(new int(3));//等价于std::shared_ptr&lt;int&gt; x = new int(3);</span><br><span class="line">fun(x.get());	//则fun()函数传入的形参类型为int*</span><br></pre></td></tr></table></figure>

- reset(): 当引用计数减1等于0时才有效，当引用计数不等于0的时候不操作
       尝试将shared_ptr包含的指针资源擦除，接受新的指针保存地址关联新的数据，同时将引用计数变为1
        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; y(new int(3));//等价于std::shared_ptr&lt;int&gt; y = new int(3);</span><br><span class="line">y.reset(new int(100));//接受新的指针保存地址关联新的数据</span><br><span class="line">y.reset();//等价于y.reset((int*)nullptr); 不关联任何资源 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

- 指定内存回收逻辑    
自定义回收函数 内存池：不使用new和delete来生成释放内存，从已有的内存中拿出地址使用，使用完后放回
    示例：
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	void dummy(int*)&#123;&#125;	//自定义的内存回收逻辑，不调用系统默认的delete</span><br><span class="line">	std::shared_ptr&lt;int&gt; fun()</span><br><span class="line">	&#123;</span><br><span class="line">		static int res = 3;//定义的静态变量在整个程序结束时释放</span><br><span class="line">		return std::shared_ptr&lt;int&gt;(&amp;res,dummy);   //dummy 为deleter 参数 ，自定义的内存回收逻辑，res为内存池的地址，使用完后放回内存池</span><br><span class="line">	&#125;</span><br><span class="line">	int main()</span><br><span class="line">	&#123;</span><br><span class="line">		auto y = fun();</span><br><span class="line">	&#125;//这里开始销毁，释放空间</span><br><span class="line"></span><br><span class="line">	```		</span><br><span class="line"></span><br><span class="line">- std::make_shared</span><br><span class="line">	shared_ptr 保存两个地址，一个是数据的地址，一个是引用计数的地址。使用传统的方法两者的内存位置可能相差甚远，在访问时效率不高</span><br><span class="line">	使用 auto ptr = std::make_ shared&lt;int&gt;(3);   传入的不再是一个地址，而是一个数据3，那么会先分配一块内存将3写入内存，会再构造一个内存存放引用计数</span><br><span class="line">	系统会引入优化将两个内存存放的尽量近</span><br><span class="line"></span><br><span class="line">- 对对象数组的支持（C++17 支持shared_ptr&lt;T[]&gt;; C++20支持make_shared分配数组）			</span><br><span class="line">- 注意：shared_ptr 管理的对象不要显示调用delete销毁，也不能两个智能指针共享一块数据内存，但不共享引用计数的内存						</span><br><span class="line">	例如：</span><br></pre></td></tr></table></figure>
    int* ptr = new int(3);
    std::shared_ptr&lt;int&gt; x(ptr);//x认为自己有对ptr对应地址的所有权                         
    std::shared_ptr&lt;int&gt; y(ptr);//y也认为自己有对ptr对应地址的所有权
    //在销毁的时候，对于ptr地址会使用两次delete
    ```                                                 
</code></pre>
]]></content>
      <tags>
        <tag>c++; 指针</tag>
      </tags>
  </entry>
  <entry>
    <title>流的状态</title>
    <url>/2022/02/06/%E6%B5%81%E7%9A%84%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="iostate-流的状态"><a href="#iostate-流的状态" class="headerlink" title="iostate 流的状态"></a>iostate 流的状态</h2><p>  goodbit= 0; //无错误<br>  以下均为/<em>implementation defined</em>/ 设备定义，不同设备可能不同<br>  例如<br>  badbit = 0000 0001 不可恢复的流错误<br>  Failbit = 0000 0010 输入/输出操作失败（格式化或提取错误）类型转换失败，可以恢复的错误<br>  eofbit = 0000 0100 关联的输入序列已抵达文件尾<br>  指定的流状态标志，它是位掩码类型</p>
<p>· 检测流的状态</p>
<ul>
<li>good() / fail() / eof() 方法</li>
<li>转换为bool值</li>
</ul>
<p>· 注意区分fail和eof</p>
<ul>
<li>可能会被同时设置，但两者的含义不同</li>
<li>转换为bool值时不会考虑eof</li>
</ul>
<p>· 通常来说，只要处于某种错误状态时，插入/提取操作就不会生效。</p>
<p>· 复位流状态</p>
<ul>
<li>clear : 设置流的状态为具体的值，缺省为goodbit</li>
<li>setstate : 将某个状态附加到现有的流状态上</li>
</ul>
<p>· 捕捉流异常：exceptions方法</p>
<hr>
<h2 id="流的定位"><a href="#流的定位" class="headerlink" title="流的定位"></a>流的定位</h2><p>· 获取流的位置</p>
<ul>
<li>tellg() / tellp() 可以获取输入/输出流的位置（pos_type类型）</li>
<li>两个方法可能都会失败，此时返回pos_type(-1)</li>
<li>当流的状态处于错误（fail或者bad状态）会返回失败-1</li>
</ul>
<p>· 设置流的位置</p>
<ul>
<li>seekg() / seekp() 用于设置输入/输出流的位置  注意会从这个地方开始覆盖，而不是插入，插入需要编写自己的逻辑</li>
<li>这两个方法分别有两个重载版本：<br>· 设置绝对位置：传入pos_type（流的位置）进行设置<br>  · 设置相对位置: 通过偏移量（字符串ios_base::beg）+ 流位置符号的方式设置<ul>
<li>ios_base::beg</li>
<li>ios_base::cur</li>
<li>ios_base::end</li>
</ul>
</li>
</ul>
<hr>
<h2 id="流的同步"><a href="#流的同步" class="headerlink" title="流的同步"></a>流的同步</h2><p>将数据由缓冲区写入到相应的设备中<br>· 基于flush()/sync()/unitbuf的同步<br>    - flush() 用于输出流同步，刷新缓冲区 std::cout.flush();或者&lt;&lt;std::flush;   &lt;&lt;std::end -&gt;包含\n和刷新缓冲区<br>    - sync() 用于输入流的同步，其实现逻辑是编译器所定义的。<br>    - 输出流可以通过设置unitbuf（在这里的缓冲区大小为1）来保证每次输出后自动同步（刷新）例如std::cerr</p>
<p>· 基于绑定（tie）的同步<br>    - 流可以绑定到一个输出流上，这样在每次输入/输出前都可以刷新输出流的缓冲区 例如:a-&gt;b,不管a是什么流，a绑定b 在操作a时会先刷新b的缓冲区<br>    - 比如 ：cin 绑定到 cout</p>
<p>· 与c语言标准io的同步<br>    - 缺省情况下，c++的输入输出操作会与c的输入输出函数同步<br>    - 可以通过sync_with_stdio关闭该同步，关闭之后无法保证c和c++的输出顺序  </p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针2</title>
    <url>/2022/02/07/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%882/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="unique-ptr-gt-独占内存的解决方案"><a href="#unique-ptr-gt-独占内存的解决方案" class="headerlink" title="unique_ptr -&gt; 独占内存的解决方案"></a>unique_ptr -&gt; 独占内存的解决方案</h2><ul>
<li><p>基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unqiue_ptr&lt;int&gt;x=new int(3);//x将独占返回的资源地址</span><br><span class="line">std::unqiue_ptr&lt;int&gt;y=x;//编译器将直接报错，不能共享</span><br><span class="line">std::unique_ptr&lt;int&gt;=std::move(x);//使用move构造一个将亡值，将x的地址转移给y，x将丧失对这个地址的拥有权</span><br><span class="line"></span><br><span class="line">//以下代码合法，c++使用移动的方式，创建临时对象，将地址传递给临时对象，再传给x</span><br><span class="line">std::unique_ptr&lt;int&gt; fun()</span><br><span class="line">&#123;</span><br><span class="line">   std::unique_ptr&lt;int&gt; res(new int(3));</span><br><span class="line">   //auto res = std::make_unique&lt;int&gt;(3); //在内部分配内存并将3写入到内存中</span><br><span class="line">   return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   std::unqiue_ptr&lt;int&gt; x=fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>unique_ptr不支持复制，但可以移动</p>
</li>
<li><p>为unique_ptr指定内存回收逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line"></span><br><span class="line">void fun(int* ptr)</span><br><span class="line">&#123;</span><br><span class="line">   std::cout&lt;&lt;&quot;fun is called \n&quot;;</span><br><span class="line">   delete ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   std::share_ptr&lt;int&gt; x(new int(3),fun);//指定内存回收逻辑 std::share_ptr&lt;class T&gt; 只有一个模板参数</span><br><span class="line">   std::unique_ptr&lt;int&gt; x(new int(3));//std::unique_ptr&lt;class T,class deleter&gt;有两个模板参数，默认使用class Deleter = std::default delete&lt;T&gt;</span><br><span class="line">   std::unique_ptr&lt;int,decltype(&amp;fun)&gt; x(new int(3),fun);//对fun函数取地址，在使用decltype推导出fun的类型 指定内存回收逻辑</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
</search>
